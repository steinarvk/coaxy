package coaxyexpr

// name
// expr DOT name
// expr LBRACKET index RBRACKET 
// expr LBRACKET quoted-string RBRACKET 

type parser Peg {
  expression expression
  identifier string
  stringLiteral string
  integer int
}

Expr <- FilteredExpr (Whitespace? COMMA Whitespace? FilteredExpr)* END

UnfilteredExpr <- Root PathComponent*
FilteredExpr <- UnfilteredExpr Filter*

Filter <- Whitespace? PIPE Whitespace? FilterCore
FilterCore <- Identifier

Root <- RootField / RootIndex / BracketedRootIndex / BracketedRootField

PathComponent
  <- ( FieldAccess
     / IndexAccess
     / BracketedFieldAccess
     / BracketedIndexAccess
     )

RootField <- (DOLLAR DOT)? Identifier {
  p.expression.addKey(p.identifier)
}

RootIndex <- (DOLLAR DOT)? Integer {
  p.expression.addIndex(p.integer)
}

BracketedRootIndex <- DOLLAR LBRACKET Integer RBRACKET {
  p.expression.addIndex(p.integer)
}

BracketedRootField <- DOLLAR LBRACKET StringLiteral RBRACKET {
  p.expression.addKey(p.stringLiteral)
}

FieldAccess <- DOT Identifier {
  p.expression.addKey(p.identifier)
}

BracketedFieldAccess <- LBRACKET StringLiteral RBRACKET {
  p.expression.addKey(p.stringLiteral)
}

BracketedIndexAccess <- LBRACKET Integer RBRACKET {
  p.expression.addIndex(p.integer)
}

IndexAccess <- DOT Integer {
  p.expression.addIndex(p.integer)
}

DOT <- '.'
LBRACKET <- '['
RBRACKET <- ']'
DOLLAR <- '$'
PIPE <- '|'
COMMA <- ','

DQUOTE <- '"'
BACKSLASH <- '\\'


StringLiteral <- < DQUOTE StringChar* DQUOTE > {
  s, _ := strconv.Unquote(text)
  p.stringLiteral = s
}

StringChar <- Escape / ![\"\n\\] .

Escape <- BACKSLASH [\"\n\\]


Integer <- < '0' / ([1-9] [0-9]*) > {
  n, _ := strconv.Atoi(text)
  p.integer = n
}

Identifier <- < IdentifierInitialChar IdentifierContinuedChar* > {
  p.identifier = text
}

IdentifierInitialChar <- [a-zA-Z]
IdentifierContinuedChar <- [a-zA-Z_0-9]

Whitespace <- [\t ]+

END <- !.
